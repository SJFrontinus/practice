<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Thousand Thanks</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #canvas {
            display: block;
            background: linear-gradient(135deg, #87CEEB 0%, #B0E0E6 100%);
            border: 20px solid white;
            cursor: pointer;
            touch-action: none;
        }

        #restartBtn {
            position: absolute;
            top: 30px;
            right: 30px;
            padding: 12px 24px;
            background: white;
            border: 3px solid #4A90E2;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            color: #4A90E2;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s;
            z-index: 10;
        }

        #restartBtn:hover {
            background: #4A90E2;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

        #restartBtn:active {
            transform: translateY(0);
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: bold;
            color: white;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.3);
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            white-space: nowrap;
        }

        @media (max-width: 600px) {
            #canvas {
                border: 10px solid white;
            }
            #restartBtn {
                top: 15px;
                right: 15px;
                padding: 10px 20px;
                font-size: 14px;
            }
            #message {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="restartBtn">Restart</button>
    <div id="message">Grazie mille!</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const restartBtn = document.getElementById('restartBtn');
        const messageEl = document.getElementById('message');

        // Responsive canvas sizing
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let emojis = [];
        let isPressed = false;
        let pointerX = 0;
        let pointerY = 0;
        let emissionTimer = 0;
        let celebrationMode = false;
        let popTimer = 0;
        let popInterval = 500; // Start slow, will accelerate
        let audioContext = null;

        const EMOJI_SIZE = 30;
        const POPCORN_SIZE = 150; // 5x the ball size
        const EMISSION_RATE = 50; // per second
        const EMISSION_INTERVAL = 1000 / EMISSION_RATE; // milliseconds
        const GRAVITY = 0.5;
        const BOUNCE_DAMPING = 0.7;
        const FRICTION = 0.99;
        const MAX_EMOJIS = 1000;

        // Unique ID counter for consistent rendering
        let emojiIdCounter = 0;

        // Emoji class
        class Emoji {
            constructor(x, y, type = 'üôè') {
                this.id = emojiIdCounter++;
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5 - 2;
                this.type = type;
                this.size = type === 'üôè' ? EMOJI_SIZE : POPCORN_SIZE;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.isPopcorn = type === 'üçø';
            }

            update() {
                // Apply gravity
                this.vy += GRAVITY;

                // Apply friction
                this.vx *= FRICTION;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Update rotation
                this.rotation += this.rotationSpeed;

                // Floor collision
                if (this.y + this.size/2 > canvas.height) {
                    this.y = canvas.height - this.size/2;
                    this.vy *= -BOUNCE_DAMPING;
                    this.vx *= FRICTION;

                    // Stop small bounces
                    if (Math.abs(this.vy) < 0.5) {
                        this.vy = 0;
                    }
                }

                // Wall collisions
                if (this.x - this.size/2 < 0) {
                    this.x = this.size/2;
                    this.vx *= -BOUNCE_DAMPING;
                } else if (this.x + this.size/2 > canvas.width) {
                    this.x = canvas.width - this.size/2;
                    this.vx *= -BOUNCE_DAMPING;
                }

                // Ceiling collision
                if (this.y - this.size/2 < 0) {
                    this.y = this.size/2;
                    this.vy *= -BOUNCE_DAMPING;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.isPopcorn) {
                    this.drawPopcorn();
                } else {
                    this.drawBubble();
                }

                ctx.restore();
            }

            drawBubble() {
                const radius = this.size / 2;

                // Draw bubble sphere with gradient
                const gradient = ctx.createRadialGradient(
                    -radius * 0.3, -radius * 0.3, radius * 0.1,  // highlight offset
                    0, 0, radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(0.2, 'rgba(200, 230, 255, 0.6)');
                gradient.addColorStop(0.7, 'rgba(150, 200, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(100, 150, 200, 0.2)');

                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Add rim/edge highlight
                const rimGradient = ctx.createRadialGradient(0, 0, radius * 0.8, 0, 0, radius);
                rimGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                rimGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');
                rimGradient.addColorStop(1, 'rgba(255, 255, 255, 0.4)');

                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fillStyle = rimGradient;
                ctx.fill();

                // Draw üôè emoji inside (prominent)
                ctx.font = `${this.size * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üôè', 0, 0);
            }

            drawPopcorn() {
                const scale = this.size / 150; // normalize to base size

                // Seed random based on unique ID for consistent appearance
                const seed = this.id * 12345;
                const pseudoRandom = (n) => {
                    const x = Math.sin(seed + n) * 10000;
                    return x - Math.floor(x);
                };

                // Draw irregular popcorn kernel shape
                ctx.beginPath();

                // Create fluffy, irregular popcorn shape with multiple lobes
                const lobes = 5 + Math.floor(pseudoRandom(1) * 3);
                const baseRadius = 60 * scale;

                for (let i = 0; i <= lobes * 10; i++) {
                    const angle = (i / (lobes * 10)) * Math.PI * 2;
                    const lobeAngle = angle * lobes;

                    // Vary radius to create bumpy surface
                    const radiusVariation = 0.7 + 0.3 * Math.abs(Math.sin(lobeAngle));
                    const bumpiness = 0.85 + 0.15 * Math.sin(angle * 7 + pseudoRandom(2) * 10);
                    const r = baseRadius * radiusVariation * bumpiness;

                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;

                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.closePath();

                // Fill with cream/yellow gradient
                const popcornGradient = ctx.createRadialGradient(
                    -20 * scale, -20 * scale, 10 * scale,
                    0, 0, 70 * scale
                );
                popcornGradient.addColorStop(0, '#FFFEF0');  // Light cream highlight
                popcornGradient.addColorStop(0.3, '#FFF8DC'); // Cornsilk
                popcornGradient.addColorStop(0.6, '#F5DEB3'); // Wheat
                popcornGradient.addColorStop(1, '#DEB887');   // Burlywood (shadow)

                ctx.fillStyle = popcornGradient;
                ctx.fill();

                // Add texture/crevice lines
                ctx.strokeStyle = 'rgba(180, 140, 80, 0.4)';
                ctx.lineWidth = 1 * scale;

                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    const startAngle = pseudoRandom(i + 10) * Math.PI * 2;
                    const length = 20 + pseudoRandom(i + 20) * 30;
                    ctx.moveTo(
                        Math.cos(startAngle) * 10 * scale,
                        Math.sin(startAngle) * 10 * scale
                    );
                    ctx.quadraticCurveTo(
                        Math.cos(startAngle + 0.3) * length * scale * 0.7,
                        Math.sin(startAngle + 0.3) * length * scale * 0.7,
                        Math.cos(startAngle + 0.5) * length * scale,
                        Math.sin(startAngle + 0.5) * length * scale
                    );
                    ctx.stroke();
                }

                // Add subtle kernel base (the brown bit)
                ctx.beginPath();
                ctx.ellipse(0, 45 * scale, 15 * scale, 10 * scale, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#B8860B'; // Dark goldenrod
                ctx.fill();
            }
        }

        // Web Audio API - Popcorn pop sound
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playPopSound() {
            if (!audioContext) initAudio();

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Pop sound characteristics
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Emit emoji at pointer location
        function emitEmoji() {
            if (emojis.length < MAX_EMOJIS) {
                emojis.push(new Emoji(pointerX, pointerY));
            }

            // Check if we hit 1000
            if (emojis.length === MAX_EMOJIS && !celebrationMode) {
                startCelebration();
            }
        }

        // Start celebration mode
        function startCelebration() {
            celebrationMode = true;

            // Show message
            messageEl.style.opacity = '1';
            messageEl.style.transition = 'opacity 0.5s';

            // Start popping emojis
            popTimer = 0;
        }

        // Pop emojis into popcorn
        function popEmojis(deltaTime) {
            popTimer += deltaTime;

            if (popTimer >= popInterval) {
                popTimer = 0;

                // Find a random thanks emoji and pop it
                const thanksEmojis = emojis.filter(e => !e.isPopcorn);
                if (thanksEmojis.length > 0) {
                    const randomEmoji = thanksEmojis[Math.floor(Math.random() * thanksEmojis.length)];
                    randomEmoji.type = 'üçø';
                    randomEmoji.size = POPCORN_SIZE;
                    randomEmoji.isPopcorn = true;
                    randomEmoji.vy = -10 - Math.random() * 5; // Pop up!
                    randomEmoji.vx = (Math.random() - 0.5) * 8;

                    playPopSound();

                    // Accelerate popping
                    popInterval *= 0.95;
                    if (popInterval < 20) popInterval = 20; // Cap at 50/sec
                }

                // Check if all are popcorn
                if (thanksEmojis.length === 1) {
                    // Wait 10 seconds then restart
                    setTimeout(restart, 10000);
                }
            }
        }

        // Restart function
        function restart() {
            emojis = [];
            emojiIdCounter = 0;
            celebrationMode = false;
            popTimer = 0;
            popInterval = 500;
            messageEl.style.opacity = '0';
            isPressed = false;
        }

        // Pointer events (unified for mouse and touch)
        function handlePointerDown(e) {
            e.preventDefault();
            isPressed = true;
            updatePointerPosition(e);
            initAudio(); // Initialize audio context on first interaction
        }

        function handlePointerMove(e) {
            e.preventDefault();
            updatePointerPosition(e);
        }

        function handlePointerUp(e) {
            e.preventDefault();
            isPressed = false;
        }

        function updatePointerPosition(e) {
            if (e.touches) {
                pointerX = e.touches[0].clientX;
                pointerY = e.touches[0].clientY;
            } else {
                pointerX = e.clientX;
                pointerY = e.clientY;
            }
        }

        // Event listeners
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mouseleave', handlePointerUp);

        canvas.addEventListener('touchstart', handlePointerDown);
        canvas.addEventListener('touchmove', handlePointerMove);
        canvas.addEventListener('touchend', handlePointerUp);

        restartBtn.addEventListener('click', restart);

        // Animation loop
        let lastTime = performance.now();
        let emissionAccumulator = 0;

        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Emit emojis while pressed
            if (isPressed && !celebrationMode) {
                emissionAccumulator += deltaTime;
                while (emissionAccumulator >= EMISSION_INTERVAL) {
                    emitEmoji();
                    emissionAccumulator -= EMISSION_INTERVAL;
                }
            }

            // Update and draw all emojis
            for (const emoji of emojis) {
                emoji.update();
                emoji.draw();
            }

            // Pop emojis during celebration
            if (celebrationMode) {
                popEmojis(deltaTime);
            }

            requestAnimationFrame(animate);
        }

        // Start animation
        animate(performance.now());
    </script>
</body>
</html>
